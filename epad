''' ePad - a simple text editor written in Elementary and Python'''
# pylint: disable=too-many-lines

#!/usr/bin/python
# encoding: utf-8

import errno
import sys
import os
import urllib.request
import urllib.parse
import urllib.error
import io
import json
from collections import Mapping

import re

from efl import ecore
from efl.evas import EVAS_HINT_EXPAND, EVAS_HINT_FILL, \
    EVAS_CALLBACK_KEY_UP, EVAS_EVENT_FLAG_ON_HOLD
from efl import elementary
from efl.elementary.window import StandardWindow
from efl.elementary.box import Box
from efl.elementary.button import Button
from efl.elementary.label import Label, ELM_WRAP_WORD
from efl.elementary.icon import Icon
from efl.elementary.notify import Notify, ELM_NOTIFY_ALIGN_FILL
from efl.elementary.separator import Separator
from efl.elementary.scroller import Scroller
from efl.elementary.frame import Frame
from efl.elementary.entry import Entry, ELM_TEXT_FORMAT_PLAIN_UTF8, \
        markup_to_utf8, utf8_to_markup, ELM_WRAP_NONE, ELM_WRAP_MIXED
from efl.elementary.popup import Popup
from efl.elementary.toolbar import Toolbar, ELM_OBJECT_SELECT_MODE_DEFAULT
from efl.elementary.flip import Flip, ELM_FLIP_ROTATE_XZ_CENTER_AXIS, \
        ELM_FLIP_ROTATE_YZ_CENTER_AXIS, ELM_FLIP_INTERACTION_ROTATE
from efl.elementary.table import Table
from efl.elementary.check import Check
from efl.elementary.naviframe import Naviframe

# Imported here to stop class resolver complaining when an input event
# applies to an internal layout object
from efl.elementary.layout import Layout

from elmextensions import AboutWindow, InstanceError
from elmextensions import FileSelector
from elmextensions import TabbedBox


#
# This program is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.

  # May as well bite the bullet

__author__ = "Jeff Hoogland"
__contributors__ = ["Jeff Hoogland", "Robert Wiley", "Kai Huuhko", "Scimmia22"]
__copyright__ = "Copyright (C) 2015 Bodhi Linux"
__appname__ = 'epad'
__version__ = "0.9.6"
__description__ = 'A simple text editor for the Enlightenment Desktop.'
__github__ = 'http://jeffhoogland.github.io/ePad/'
__source__ = 'Source code and bug reports: {0}'.format(__github__)
PY_EFL = "https://git.enlightenment.org/bindings/python/python-efl.git/"

AUTHORS = """
<br>
<align=center>
<hilight>Jeff Hoogland (Jef91)</hilight><br>
<link><a href=http://www.jeffhoogland.com>Contact</a></link><br><br>

<hilight>Robert Wiley (ylee)</hilight><br><br>

<hilight>Kai Huuhko (kuuko)</hilight><br><br>
</align>
"""

LICENSE = """<br>
<align=center>
<hilight>
GNU GENERAL PUBLIC LICENSE<br>
Version 3, 29 June 2007<br><br>
</hilight>

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.<br><br>

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
GNU General Public License for more details.<br><br>

You should have received a copy of the GNU General Public License
along with this program. If not, see<br>
<link><a href=http://www.gnu.org/licenses>http://www.gnu.org/licenses/</a></link>
</align>
<br>
"""

INFO = """
<align=center>
<hilight>ePad</hilight> is a simple text editor written in Elementary and Python.<br>
<br>
<br>
</align>
"""


EXPAND_BOTH = EVAS_HINT_EXPAND, EVAS_HINT_EXPAND
EXPAND_HORIZ = EVAS_HINT_EXPAND, 0.0
FILL_BOTH = EVAS_HINT_FILL, EVAS_HINT_FILL
FILL_HORIZ = EVAS_HINT_FILL, 0.5
EXPAND_NONE = 0.0, 0.0
ALIGN_CENTER = 0.5, 0.5
ALIGN_RIGHT = 1.0, 0.5
ALIGN_LEFT = 0.0, 0.5
PADDING = 15, 0


def print_err(*args, **kwargs):
    """
    error message to stderr
    """
    print('[ePad]:', *args, file=sys.stderr, **kwargs)

def error_popup(window, error_msg):
    ''' error message alert window '''
    err_popup = Popup(window, size_hint_weight=EXPAND_BOTH)
    err_popup.callback_block_clicked_add(lambda obj: error_popup.delete())

    # Add a table to hold dialog image and text to Popup
    _tb = Table(error_popup, size_hint_weight=EXPAND_BOTH)
    err_popup.part_content_set("default", _tb)
    _tb.show()

    # Add dialog-error Image to table
    icon = Icon(error_popup, resizable=(True, True),
                size_hint_weight=EXPAND_BOTH, size_hint_align=FILL_BOTH)
    icon.standard_set('dialog-warning')
    _tb.pack(icon, 0, 0, 1, 1)
    icon.show()

    # Add dialog text to table
    dialog_label = Label(err_popup, line_wrap=ELM_WRAP_WORD,
                         size_hint_weight=EXPAND_HORIZ,
                         size_hint_align=FILL_BOTH)
    dialog_label.text = error_msg
    _tb.pack(dialog_label, 1, 0, 1, 1)
    dialog_label.show()

    # Ok Button
    ok_btt = Button(err_popup)
    ok_btt.text = "Ok"
    ok_btt.callback_clicked_add(lambda obj: err_popup.delete())
    ok_btt.show()

    # add button to popup
    err_popup.part_content_set("button3", ok_btt)
    err_popup.show()


def close_menu(obj, label):
    ''' close the menu regarless if anything selected '''
    if not hasattr(close_menu, 'count'):
        close_menu.count = 0
    if not hasattr(close_menu, 'name'):
        close_menu.lastItem = label
    if close_menu.lastItem != label:
        close_menu.count = 0
    if close_menu.count:
        obj.selected_set(False)
        obj.menu_get().close()
    close_menu.count = (close_menu.count + 1) % 2


def reset_close_menu_count():
    ''' define count '''
    global CLOSE_MENU
    if hasattr(close_menu, 'count'):
        close_menu.count = 0

#pylint: disable=too-many-public-methods
class Interface(object):
    ''' primary window for editor '''
    # pylint: disable=too-many-instance-attributes, too-many-statements
    def __init__(self):
        self.cnfrm_popup = None
        self.config = ePadConf()

        self.main_window = StandardWindow("epad", "Untitled - ePad",
                                          size=(600, 400))
        self.main_window.callback_delete_request_add(self.close_checks)
        self.main_window.elm_event_callback_add(self.events_cb)
        #self.main_window.repeat_events_set(False)

        icon = Icon(self.main_window,
                    size_hint_weight=EXPAND_BOTH,
                    size_hint_align=FILL_BOTH)
        icon.standard_set('accessories-text-editor')
        icon.show()
        self.main_window.icon_object_set(icon.object_get())

        self.main_box = Box(self.main_window,
                            size_hint_weight=EXPAND_BOTH,
                            size_hint_align=FILL_BOTH)
        self.main_box.show()

        self.main_tab = ePadToolbar(self, self.main_window)
        self.main_tab.focus_allow = False
        self.main_tab.show()

        self.main_box.pack_end(self.main_tab)

        # Root User Notification
        if os.geteuid() == 0:
            # print_err("Caution: Root User")
            if self.config["notify_root"]:
                notify_box = Box(self.main_window, horizontal=True,
                                 size_hint_weight=EXPAND_HORIZ,
                                 size_hint_align=FILL_BOTH)
                notify_lbl = Label(self.main_window, style="default/center",
                                   size_hint_weight=EXPAND_HORIZ,
                                   size_hint_align=FILL_BOTH)
                notify_lbl.text = "<b><i>Root User</i></b>"
                notify_box.pack_end(notify_lbl)
                notify_lbl.show()
                self.main_box.pack_end(notify_box)
                notify_box.show()

        self.find_box = EPadFindBox(self, self.main_window)
        self.find_visible = False

        self.tabbs = TabbedBox(self.main_window, size_hint_weight=EXPAND_BOTH,
                               size_hint_align=FILL_BOTH)
        self.tabbs.closeCallback = self.close_file
        self.tabbs.emptyCallback = self.base_file
        self.tabbs.tabChangedCallback = self.tab_changed
        self.tabbs.show()

        self.main_box.pack_end(self.tabbs)

        # Build our file selector for saving/loading files
        self.file_box = Box(self.main_window,
                            size_hint_weight=EXPAND_BOTH,
                            size_hint_align=FILL_BOTH)
        self.file_box.show()

        self.file_lbl = Label(self.main_window,
                              size_hint_weight=EXPAND_HORIZ,
                              size_hint_align=FILL_BOTH, text="")
        self.file_lbl.show()
        self.last_dir = os.getenv("HOME")
        self.file_slctr = FileSelector(self.main_window,
                                       defaultPath=self.last_dir,
                                       defaultPopulate=False,
                                       size_hint_weight=EXPAND_BOTH,
                                       size_hint_align=FILL_BOTH)
        self.file_slctr.callback_activated_add(self.file_slctd)
        self.file_slctr.callback_directory_open_add(self.update_last_dir)
        self.file_slctr.callback_cancel_add(self.file_sel_cncl_prssd)
        self.file_slctr.set_mode("Open")
        self.file_slctr.show()

        self.file_box.pack_end(self.file_lbl)
        self.file_box.pack_end(self.file_slctr)

        # Flip object has the file selector on one side
        #   and the GUI on the other
        self.flip = Flip(self.main_window, size_hint_weight=EXPAND_BOTH,
                         size_hint_align=FILL_BOTH)
        self.flip.part_content_set("front", self.main_box)
        self.flip.part_content_set("back", self.file_box)
        self.main_window.resize_object_add(self.flip)
        self.flip.show()

    def tab_changed(self, widget):
        ''' method to allow saves '''
        self.main_window.title = widget.data["button"].text
        self.main_tab.savebtn.disabled = not widget.dirty

    def add_file(self, file_path):
        ''' method to open additional file  '''
        entry_box = EPadEntry(self, self.tabbs)
        entry_box.show()

        if file_path != "Untitled":
            entry_box.open_file(file_path)
            tab_name = file_path.split("/")[-1]
        else:
            tab_name = "Untitled"
        entry_box.curChanged(entry_box.mainEn, entry_box.line_label)
        entry_box.checkLineNumbers()
        self.tabbs.add(entry_box, tab_name)
        entry_box.mainEn.focus_set(True)

    def base_file(self):
        ''' This function gets called when all files are closed '''
        self.add_file("Untitled")

    # pylint: disable=no-self-use
    def close_file(self, widget):
        ''' method to close file '''
        widget.close_checks()

    def show_file(self, btn):
        ''' method to display the button '''
        if self.tabbs.currentTab != btn.data["entry"]:
            self.setFile(btn.data["entry"], btn.text)

    def new_file(self):
        ''' open a new file '''
        if self.config["new_instance"]:
            print("Launching new instance")
            ecore.Exe('epad', ecore.ECORE_EXE_PIPE_READ|
                      ecore.ECORE_EXE_PIPE_ERROR|
                      ecore.ECORE_EXE_PIPE_WRITE)
            return
        self.add_file("Untitled")

    def open_file(self):
        ''' open a file for editing '''
        self.file_slctr.setMode("Open")
        self.file_lbl.text = "<b>Select a text file to open:</b>"
        if self.file_slctr.filepathEntry.text != self.last_dir:
            self.file_slctr.populateFiles(self.last_dir)
        self.flip.go(ELM_FLIP_ROTATE_YZ_CENTER_AXIS)

    def file_sel_cncl_prssd(self):
        ''' cancel file selection '''
        self.flip.go(ELM_FLIP_ROTATE_XZ_CENTER_AXIS)

    def show_find(self):
        ''' disply find dialog '''
        if not self.find_visible:
            self.main_box.pack_before(self.find_box, self.tabbs)
            self.find_box.findEntry.text = self.tabbs.currentTab.mainEn.selection_get()
            self.find_box.findEntry.focus_set(True)
            self.find_box.findEntry.cursor_end_set()
            self.find_box.show()
            self.find_visible = True
        else:
            self.hide_find()

    def hide_find(self):
        ''' hide find dialog '''
        if self.find_visible:
            self.main_box.unpack(self.find_box)
            self.find_box.hide()
            self.find_visible = False

    def save_as(self):
        ''' save edited file as new name/location '''
        self.file_slctr.setMode("Save")
        self.file_lbl.text = "<b>Save new file to where:</b>"
        if self.file_slctr.filepathEntry.text != self.last_dir:
            self.file_slctr.populateFiles(self.last_dir)
        self.flip.go(ELM_FLIP_ROTATE_XZ_CENTER_AXIS)

    def save_file(self):
        ''' save edited file in place '''
        if self.tabbs.currentTab.mainEn.file_get()[0] is None or self.tabbs.currentTab.isNewFile:
            self.save_as()
        else:
            if not self.tabbs.currentTab.is_saved:
                file_selected = self.tabbs.currentTab.mainEn.file_get()[0]
                # Detect save errors as entry.file_save currently returns no errors
                #   even in the case where the file fails to save :(
                try:
                    newfile = io.open(file_selected, 'w')
                except IOError as err:
                    if err.errno == errno.EACCES:
                        error_msg = ("Permision denied: <b>'%s'</b>."
                                     "<br><br>Operation failed !!!"
                                     % (file_selected))
                        error_popup(self.main_window, error_msg)
                    else:
                        error_msg = ("ERROR: %s: '%s'"
                                     "<br><br>Operation failed !!!"
                                     % (err.strerror, file_selected))
                        error_popup(self.main_window, error_msg)
                    return
                newfile.close()
                # if entry is empty and the file does not exists then
                #   entry.file_save will destroy the file created about by the
                #   open statement above for some odd reason ...
                if not self.tabbs.currentTab.mainEn.is_empty:
                    self.tabbs.currentTab.mainEn.file_save()
                self.tabbs.currentTab.setDirty(False)
                self.tabbs.currentTab.is_saved = True

    def file_slctd(self, _fs, file_selected, on_startup=False):
        ''' sanitize file selected reference '''
        if not on_startup:
            self.flip.go(ELM_FLIP_ROTATE_XZ_CENTER_AXIS)
            # Markup can end up in file names because file_selector name_entry
            #   is an elementary entry. So lets sanitize file_selected.
            file_selected = markup_to_utf8(file_selected)
        if file_selected:
            #print("File Selected: {0}".format(file_selected))
            self.last_dir = os.path.dirname(file_selected)
            # This fails if file_selected does not exist yet

            _fs.fileEntry.text = file_selected.split("/")[-1]

        is_save = _fs.mode

        if file_selected:
            if is_save == "save":
                if os.path.isdir(file_selected):
                    current_file = os.path.basename(file_selected)
                    error_msg = ("<b>'%s'</b> is a folder."
                                 "<br><br>Operation failed !!!"
                                 % (current_file))
                    error_popup(self.main_window, error_msg)
                    return
                elif os.path.exists(file_selected):
                    self.tabbs.currentTab.fileExists(file_selected)
                    return
                else:
                    self.tabbs.currentTab.doSelected(file_selected)
                    return
            else:
                self.add_file(file_selected)

    def update_last_dir(self, path):
        ''' maintain current memory of path '''
        self.last_dir = path

    def show_about(self):
        ''' display version information '''
        self.about.launch()

    def close_app(self):
        ''' close the epad app '''
        elementary.exit()

    def close_checks(self, obj=False):
        ''' checklist for closing '''
        all_saved = True

        for _en in self.tabbs.tabs:
            if not _en.is_saved:
                all_saved = False

        if all_saved:
            self.close_app()
        else:
            self.unsaved_work_popup()

    def close_popup(self):
        ''' close popup window '''
        self.cnfrm_popup.delete()
        self.cnfrm_popup = None

    def unsaved_work_popup(self):
        ''' remind user of changes not yet saved '''
        if self.cnfrm_popup:
            return

        self.cnfrm_popup = Popup(self.main_window,
                                 size_hint_weight=EXPAND_BOTH)

        # Add a table to hold dialog image and text to Popup
        _tb = Table(self.cnfrm_popup, size_hint_weight=EXPAND_BOTH)
        self.cnfrm_popup.part_content_set("default", _tb)
        _tb.show()

        # Add dialog-error Image to table
        icon = Icon(self.cnfrm_popup, resizable=(True, True),
                    size_hint_weight=EXPAND_BOTH, size_hint_align=FILL_BOTH)
        icon.standard_set('dialog-question')
        _tb.pack(icon, 0, 0, 1, 1)
        icon.show()
        # Add dialog text to table
        dialog_label = Label(self.cnfrm_popup, line_wrap=ELM_WRAP_WORD,
                             size_hint_weight=EXPAND_HORIZ,
                             size_hint_align=FILL_BOTH)
        dialog_label.text = "You have unsaved work. Close anyways?<br><br>"
        _tb.pack(dialog_label, 1, 0, 1, 1)
        dialog_label.show()

        # Close without saving button
        no_btt = Button(self.main_window)
        no_btt.text = "No"
        no_btt.callback_clicked_add(self.close_popup, self.cnfrm_popup)
        no_btt.show()
        # Save the file and then close button
        sav_btt = Button(self.main_window)
        sav_btt.text = "Yes"
        sav_btt.callback_clicked_add(self.close_app)
        sav_btt.show()

        # add buttons to popup
        self.cnfrm_popup.part_content_set("button1", no_btt)
        self.cnfrm_popup.part_content_set("button3", sav_btt)
        self.cnfrm_popup.show()

    # pylint: disable=too-many-branches
    def events_cb(self, src, event_type, event):
        ''' callback function for interrupt events '''

        if not event_type == EVAS_CALLBACK_KEY_UP:
            return False

        if event.modifier_is_set("Control"):
            if event.keyname == "n":
                #new_file(self.new_file)
                self.new_file()
            elif event.keyname == "s" and event.modifier_is_set("Shift"):
                self.save_as()
            elif event.keyname == "s":
                self.save_file()
            elif event.keyname == "z" and event.modifier_is_set("Shift"):
                self.tabbs.currentTab.reDo()
            elif event.keyname == "z":
                self.tabbs.currentTab.unDo()
            elif event.keyname == "o":
                self.open_file()
            elif event.keyname == "h":
                if not self.flip.front_visible_get():
                    self.file_slctr.toggleHidden()
            elif event.keyname == "q":
                self.close_checks()
            elif event.keyname == "f":
                self.show_find()
        elif isinstance(src, Entry) and event.key in ["space", "BackSpace", "Return"]:
            self.tabbs.currentTab.takeSnapShot()

        event.event_flags = event.event_flags | EVAS_EVENT_FLAG_ON_HOLD
        return True

    def launch(self, start=[]):
        ''' begin editting '''
        if start[0]:
            for count, our_file in enumerate(start[0]):
                if os.path.dirname(our_file) == '':
                    start[0][count] = os.getcwd() + '/' + our_file

        if start and start[0]:
            for our_file in start[0]:
                if our_file[:7] == "file://":
                    try:
                        our_file = urllib.request.url2pathname(our_file[7:])
                    except AttributeError:
                        # Python3
                        our_file = urllib.request.url2pathname(our_file[7:])
                if os.path.isdir(os.path.dirname(our_file)):
                    if os.path.isfile(our_file):
                        ##print(our_file)
                        self.add_file(our_file)
                else:
                    error_msg = ("<b>'%s'</b> is an Invalid path."
                                 "<br><br>Open failed !!!" % (our_file))
                    error_popup(self.main_window, error_msg)
        if start and start[1]:
            if os.path.isdir(start[1]):
                self.last_dir = start[1]
            else:
                pass

        if not len(self.tabbs.tabs):
            self.add_file("Untitled")

        self.main_window.show()

class EPadEntry(Box):

    default_font_size = 14

    def __init__(self, parent, canvas):
        Box.__init__(self, canvas)
        self._parent = parent
        self._canvas = canvas
        self._config = self._parent.config

        self.size_hint_weight = EXPAND_BOTH
        self.size_hint_align = FILL_BOTH
        # py-efl doesn't work correctly with fonts that have spaces in names
        #   Oddly enough remove spaces and works
        #   versions up to 1.18 (inclusive)
        font = self._config['font'].replace(' ', '')
        font_style = self._config['font_style']
        font_weight = self._config['font_weight']
        font_width = self._config['font_width']
        font_size = self._config['font_size']

        self.font_style = "DEFAULT='font={0} font_style={1}\
                          font_weight={2} font_width={3}\
                          font_size={4}'".format(font, font_style,
                                                 font_weight, font_width,
                                                 str(font_size))

        self.entry_box = Box(self._canvas,
                             size_hint_weight=EXPAND_BOTH,
                             size_hint_align=FILL_BOTH)
        self.entry_box.horizontal = True
        self.entry_box.show()

        # Initialize Text entry box and line label
        self.line_list = Entry(self._canvas,
                               scrollable=False, editable=False,
                               size_hint_weight=(0.0, EVAS_HINT_EXPAND),
                               size_hint_align=(0.0, 0.0),
                               line_wrap=ELM_WRAP_NONE)
        self.line_list.text_style_user_push("DEFAULT='font_size={0}'"
                                            .format(self._config['font_size']))
        self.current_lines_shown = 1
        self.line_list.text_set("<i>1<br>")

        self.line_nums = self._parent.config['line_numbers']

        self.mainEn = Entry(self._canvas, scrollable=False,
                            line_wrap=self._parent.config['word_wrap'],
                            autosave=self._parent.config['autosave'],
                            size_hint_weight=(0.85, EVAS_HINT_EXPAND),
                            size_hint_align=FILL_BOTH)
        self.mainEn.callback_changed_user_add(self.textEdited)
        self.mainEn.callback_clicked_add(reset_close_menu_count)
        self.mainEn.callback_selection_cut_add(self.takeSnapShot)
        self.mainEn.callback_selection_paste_add(self.takeSnapShot)
        # Don't let line_list steal focus
        self.line_list.callback_clicked_add(lambda o: self.mainEn.focus_set(True))
        self.mainEn.text_style_user_push(self.font_style)

        self.totalLines = 0
        self.mainEn.show()
        self.sep = Separator(self._canvas)
        self.sep.horizontal_set(False)
        self.sep.show()

        if self.line_nums:
            self.line_list.show()
            self.entry_box.pack_end(self.line_list)
            self.entry_box.pack_end(self.sep)
        self.entry_box.pack_end(self.mainEn)

        self.scr = Scroller(self._canvas,
                            size_hint_weight=EXPAND_BOTH,
                            size_hint_align=FILL_BOTH)
        self.scr.content = self.entry_box
        self.scr.show()

        self.pack_end(self.scr)

        # Add label to show current cursor position
        if self._parent.config['show_pos']:
            self.line_label = Label(self._canvas,
                                    style="default/right",
                                    size_hint_weight=EXPAND_HORIZ,
                                    size_hint_align=FILL_BOTH)

            self.mainEn.callback_cursor_changed_add(self.curChanged,
                                                    self.line_label)
            self.curChanged(self.mainEn, self.line_label)
            self.line_label.show()
            self.pack_end(self.line_label)

        self.isNewFile = True
        self.is_saved = True
        self.doArchive = []
        self.doSpot = 0
        self.takeSnapShot()
        self.setDirty(False)

    def takeSnapShot(self, obj=None):
        if self.doSpot != len(self.doArchive)-1:
            for i in range(self.doSpot+1, len(self.doArchive)):
                self.doArchive.pop(self.doSpot+1)

        curPos = self.mainEn.cursor_pos_get()
        entryGet = self.mainEn.entry_get()

        if self.doSpot == 0:
            self.saveSnapShot(curPos, entryGet)
        elif entryGet != self.doArchive[self.doSpot][1]:
            self.saveSnapShot(curPos, entryGet)

    def saveSnapShot(self, curPos, entryGet):
        self.doArchive.append([curPos, entryGet])

        if len(self.doArchive) > 30:
            self.doArchive.pop(0)

        self.doSpot = len(self.doArchive) - 1


    def unDo(self):
        if self.doSpot > 0:
            # A check if this is the first time we are undoing that we store the latest data
            if self.doSpot == len(self.doArchive) - 1:
                if self.doArchive[self.doSpot][1] != self.mainEn.entry_get():
                    self.takeSnapShot()
            self.doSpot -= 1
            self.mainEn.entry_set(self.doArchive[self.doSpot][1])
            self.mainEn.cursor_pos_set(self.doArchive[self.doSpot][0])

    def reDo(self):
        if self.doSpot + 1 < len(self.doArchive):
            self.doSpot += 1
            self.mainEn.entry_set(self.doArchive[self.doSpot][1])
            self.mainEn.cursor_pos_set(self.doArchive[self.doSpot][0])

    def checkLineNumbers(self):
        if self.current_lines_shown < self.totalLines:
            lines = ""
            for i in range(self.current_lines_shown+1, self.totalLines+1):
                lines += "%s<br>"%(i)
            self.line_list.entry_append(lines)
            self.current_lines_shown = self.totalLines
        elif self.current_lines_shown > self.totalLines:
            lines = "<i>"

            for i in range(1, self.totalLines+1):
                lines = "%s%s<br>"%(lines, i)

            self.line_list.entry_set(lines)
            '''for i in range(self.totalLines+1, self.current_lines_shown+1):
                ll = self.line_list
                ll.cursor_end_set()
                ll.cursor_prev()
                ll.cursor_selection_begin()
                ll.cursor_line_begin_set()
                ll.cursor_prev()
                ll.cursor_selection_end()
                ll.selection_cut()'''

            self.current_lines_shown = self.totalLines

    def curChanged(self, entry, label):
        # get linear index into current text
        index = entry.cursor_pos_get()
        # Replace <br /> tag with single char
        #   to simplify (line, col) calculation
        tmp_text = markup_to_utf8(entry.entry_get())
        self.totalLines = tmp_text.count("\n")+1
        if self.line_nums:
            self.checkLineNumbers()
        text_slice = tmp_text[:index]
        split_line = text_slice.split("\n")
        line_n = len(split_line)
        col = len(split_line[-1]) + 1
        # Update label text with line, col
        label.text = "Ln {0} Col {1} ".format(line_n, col)

    def setDirty(self, dirty):
        if dirty:
            self.dirty = True
            self._parent.main_window.title = "*" + self._parent.main_window.title
            try:
                self.data["button"].text = "*" + self.data["button"].text
            except:
                pass
            self._parent.main_tab.savebtn.disabled = False
        else:
            self.dirty = False
            self._parent.main_window.title = self._parent.main_window.title[1:]
            try:
                self.data["button"].text = self.data["button"].text[1:]
            except:
                pass
            self._parent.main_tab.savebtn.disabled = True

    def textEdited(self, obj=None):
        if not self.dirty:
            self.setDirty(True)
        self.is_saved = False

    def open_file(self, file_path):
        try:
            self.mainEn.file_set(file_path, ELM_TEXT_FORMAT_PLAIN_UTF8)
        except (RuntimeWarning, RuntimeError) as msg:
            pass
        self.isNewFile = False
        #Reset undo/redo tracks when we open a file
        self.doArchive = []
        self.doSpot = 0
        self.takeSnapShot()
        self.mainEn.focus_set(True)

    def close_checks(self, ourCallback=None):
        if not self.is_saved:
            self.confirmSave()
        else:
            self._parent.tabbs.deleteTab(self)

    def confirmSave(self):
        self.cnfrm_popup = Popup(self._parent.main_window,
                                 size_hint_weight=EXPAND_BOTH)
        self.cnfrm_popup.part_text_set("title,text", "File Unsaved")
        current_file = self.mainEn.file[0]
        current_file = \
            os.path.basename(current_file) if current_file else "Untitled"
        self.cnfrm_popup.text = "Save changes to '%s'?" % (current_file)
        # Close without saving button
        no_btt = Button(self._parent.main_window)
        no_btt.text = "No"
        no_btt.callback_clicked_add(self.close_popup, self.cnfrm_popup)
        no_btt.callback_clicked_add(lambda o: self._parent.tabbs.deleteTab(self))
        no_btt.show()
        # cancel close request
        cancel_btt = Button(self._parent.main_window)
        cancel_btt.text = "Cancel"
        cancel_btt.callback_clicked_add(self.close_popup, self.cnfrm_popup)
        cancel_btt.show()
        # Save the file and then close button
        sav_btt = Button(self._parent.main_window)
        sav_btt.text = "Yes"
        sav_btt.callback_clicked_add(self._parent.save_file)
        sav_btt.callback_clicked_add(self.close_popup, self.cnfrm_popup)
        sav_btt.show()

        # add buttons to popup
        self.cnfrm_popup.part_content_set("button1", no_btt)
        self.cnfrm_popup.part_content_set("button2", cancel_btt)
        self.cnfrm_popup.part_content_set("button3", sav_btt)
        self.cnfrm_popup.show()

    def close_popup(self, bt, cnfrm_popup):
        self.cnfrm_popup.delete()
        self.cnfrm_popup = None

    def fileExists(self, file_path):
        self.cnfrm_popup = Popup(self._parent.main_window,
                                 size_hint_weight=EXPAND_BOTH)

        # Add a table to hold dialog image and text to Popup
        tb = Table(self.cnfrm_popup, size_hint_weight=EXPAND_BOTH)
        self.cnfrm_popup.part_content_set("default", tb)
        tb.show()

        # Add dialog-error Image to table
        icon = Icon(self.cnfrm_popup, resizable=(True, True),
                    size_hint_weight=EXPAND_BOTH,
                    size_hint_align=FILL_BOTH)
        icon.standard_set('dialog-question')
        tb.pack(icon, 0, 0, 1, 1)
        icon.show()
        # Add dialog text to table
        dialog_label = Label(self.cnfrm_popup, line_wrap=ELM_WRAP_WORD,
                             size_hint_weight=EXPAND_HORIZ,
                             size_hint_align=FILL_BOTH)
        current_file = os.path.basename(file_path)
        dialog_label.text = "'%s' already exists. Overwrite?<br><br>" \
                           % (current_file)
        tb.pack(dialog_label, 1, 0, 1, 1)
        dialog_label.show()

        # Close without saving button
        no_btt = Button(self._parent.main_window)
        no_btt.text = "No"
        no_btt.callback_clicked_add(self.close_popup, self.cnfrm_popup)
        no_btt.show()
        # Save the file and then close button
        sav_btt = Button(self._parent.main_window)
        sav_btt.text = "Yes"
        sav_btt.callback_clicked_add(self.doSelected)
        sav_btt.callback_clicked_add(self.close_popup, self.cnfrm_popup)
        sav_btt.show()

        # add buttons to popup
        self.cnfrm_popup.part_content_set("button1", no_btt)
        self.cnfrm_popup.part_content_set("button3", sav_btt)
        self.cnfrm_popup.show()

    def doSelected(self, obj):
        # Something I should avoid but here I prefer a polymorphic function
        if isinstance(obj, Button):
            file_selected = self._parent.file_slctr.selected_get()
        else:
            file_selected = obj

        if file_selected:
            try:
                newfile = io.open(file_selected, 'w')
            except IOError as err:
                pass
                #print("ERROR: {0}: '{1}'".format(err.strerror,
                #                                    file_selected))
                if err.errno == errno.EACCES:
                    error_msg = ("Permision denied: <b>'%s'</b>."
                                 "<br><br>Operation failed !!!</br>"
                                 % (file_selected))
                    error_popup(self._parent.main_window, error_msg)
                else:
                    error_msg = ("ERROR: %s: '%s'"
                                 "<br><br>Operation failed !!!</br>"
                                 % (err.strerror, file_selected))
                    error_popup(self._parent.main_window, error_msg)
                return
            tmp_text = self.mainEn.entry_get()
            # fixme: Why save twice?
            newfile.write(tmp_text)
            newfile.close()
                # Suppress error message when empty file is saved
            try:
                self.mainEn.file_set(file_selected,
                                     ELM_TEXT_FORMAT_PLAIN_UTF8)
            except RuntimeError:
                pass
                # print("Empty file saved:{0}".format(file_selected))
            self.mainEn.entry_set(tmp_text)
                # if empty file entry.file_save destroys file :(
            if len(tmp_text):
                self.mainEn.file_save()
            self._parent.main_window.title_set(" %s - ePad" % os.path.basename(file_selected))
            self.data["button"].text = " %s" % os.path.basename(file_selected)

            self.is_saved = True
            self.isNewFile = False
            self.setDirty(False)

class EPadFindBox(Box):
    def __init__(self, parent, canvas):
        Box.__init__(self, canvas)
        self._parent = parent
        self._canvas = canvas

        self.size_hint_weight = EXPAND_HORIZ
        self.size_hint_align = FILL_HORIZ

        self.current_find = None
        self.lastSearch = None

        frameBox = Box(self._canvas, size_hint_weight=EXPAND_HORIZ, size_hint_align=FILL_HORIZ)
        frameBox.horizontal = True
        frameBox.show()

        findBox = Frame(self._canvas, size_hint_weight=EXPAND_HORIZ, size_hint_align=FILL_HORIZ)
        findBox.text = "Find Text:"
        findBox.show()

        self.findEntry = Entry(self._canvas,
                               size_hint_weight=EXPAND_HORIZ,
                               size_hint_align=FILL_HORIZ)
        self.findEntry.single_line_set(True)
        self.findEntry.scrollable_set(True)
        self.findEntry.callback_activated_add(self.findPressed)
        self.findEntry.show()

        findBox.content = self.findEntry

        replaceBox = Frame(self._canvas,
                           size_hint_weight=EXPAND_HORIZ,
                           size_hint_align=FILL_HORIZ)
        replaceBox.text = "Replace Text:"
        replaceBox.show()

        self.replaceEntry = Entry(self._canvas,
                                  size_hint_weight=EXPAND_HORIZ,
                                  size_hint_align=FILL_HORIZ)
        self.replaceEntry.single_line_set(True)
        self.replaceEntry.scrollable_set(True)
        self.replaceEntry.show()

        replaceBox.content = self.replaceEntry

        frameBox.pack_end(findBox)
        frameBox.pack_end(replaceBox)

        buttonBox = Box(self._canvas, size_hint_weight=EXPAND_HORIZ, size_hint_align=FILL_HORIZ)
        buttonBox.horizontal = True
        buttonBox.show()

        findButton = Button(self._canvas)
        findButton.text = "Find Next"
        findButton.callback_pressed_add(self.findPressed)
        findButton.show()

        replaceButton = Button(self._canvas)
        replaceButton.text = "Replace All"
        replaceButton.callback_pressed_add(self.replacePressed)
        replaceButton.show()

        closeButton = Button(self._canvas)
        closeButton.text = "Done"
        closeButton.callback_pressed_add(self._parent.show_find)
        closeButton.show()

        self.caseCheck = Check(self._canvas, text="Case Sensitive")
        self.caseCheck.state_set(self._parent.config['case_sensitive'])
        self.caseCheck.callback_changed_add(self.caseUpdate)
        self.caseCheck.show()

        buttonBox.pack_end(self.caseCheck)
        buttonBox.pack_end(findButton)
        buttonBox.pack_end(replaceButton)
        buttonBox.pack_end(closeButton)

        self.pack_end(frameBox)
        self.pack_end(buttonBox)

    def replacePressed(self, obj):
        tmp_text = markup_to_utf8(self._parent.tabbs.currentTab.mainEn.entry_get())
        if not self.caseCheck.state_get():
            search_string = self.findEntry.text.lower()
            locations = list(self.findAll(tmp_text.lower(), search_string))
        else:
            search_string = self.findEntry.text
            locations = list(self.findAll(tmp_text, search_string))
        search_length = len(search_string)
        if search_length:
            replace_string = self.replaceEntry.text
            #if replace_string:
            if len(locations):
                if not self._parent.config['case_sensitive']:
                    ourRe = re.compile(search_string, re.IGNORECASE)
                else:
                    ourRe = re.compile(search_string)
                tmp_text = ourRe.sub(replace_string, tmp_text).encode('utf-8').strip()
                tmp_text = utf8_to_markup(tmp_text)
                curPos = self._parent.tabbs.currentTab.mainEn.cursor_pos_get()
                self._parent.tabbs.currentTab.mainEn.text_set(tmp_text)
                try:
                    self._parent.tabbs.currentTab.mainEn.cursor_pos_set(curPos)
                except:
                    pass
                    #print("Error: Can't set cursor position")
                self._parent.tabbs.currentTab.textEdited()
                self._parent.tabbs.currentTab.takeSnapShot()
            else:
                error_popup(self._parent.main_window,
                            "Text %s not found. Nothing\
                             replaced."%search_string)
            # else:
            #    error_popup(self._parent.main_window, "No replacement string entered.")
        else:
            error_popup(self._parent.main_window, "No find string entered.")

    def findPressed(self, obj):
        if not self.caseCheck.state_get():
            search_string = self.findEntry.text.lower()
            tmp_text = markup_to_utf8(self._parent.tabbs.currentTab.mainEn.entry_get()).lower()
        else:
            search_string = self.findEntry.text
            tmp_text = markup_to_utf8(self._parent.tabbs.currentTab.mainEn.entry_get())
        search_length = len(search_string)
        if search_length:
            locations = list(self.findAll(tmp_text, search_string))
            if len(locations):
                if self.current_find == None or search_string != self.lastSearch:
                    self.lastSearch = search_string
                    self.current_find = locations[0]
                else:
                    lastFind = locations.index(self.current_find)
                    if lastFind < len(locations)-1:
                        self.current_find = locations[lastFind+1]
                    else:
                        self.current_find = locations[0]
                self._parent.tabbs.currentTab.mainEn\
                .select_region_set(self.current_find,
                                   self.current_find+search_length)
            else:
                error_popup(self._parent.main_window, "Text %s not found."%search_string)
        else:
            error_popup(self._parent.main_window, "No find string entered.")

    def findAll(self, a_str, sub):
        start = 0
        while True:
            start = a_str.find(sub, start)
            if start == -1: return
            yield start
            start += len(sub) + 1

    def caseUpdate(self, ck):
        self._parent.config['case_sensitive'] = ck.state_get()


class ePadToolbar(Toolbar):
    def __init__(self, parent, canvas):
        Toolbar.__init__(self, canvas)
        self._parent = parent
        self._canvas = canvas

        self.homogeneous = False
        self.size_hint_weight = (0.0, 0.0)
        self.size_hint_align = (EVAS_HINT_FILL, 0.0)
        self.select_mode = ELM_OBJECT_SELECT_MODE_DEFAULT
        self.icon_size_set(16)
        self.callback_selected_add(self.itemClicked)

        self.menu_parent = canvas

        self.item_append("document-new", "New",
                         lambda self, obj: self._parent.new_file())
        self.item_append("document-open", "Open",
                         lambda self, obj: self._parent.open_file())
        self.savebtn = self.item_append("document-save", "Save",
                                        lambda self,
                                               obj: self._parent.save_file())
        self.savebtn.disabled = True
        self.item_append("document-save-as", "Save As",
                         lambda self, obj: self._parent.save_as())
        # -- Edit Dropdown Menu --
        tb_it = self.item_append("edit-copy", "Edit")
        tb_it.menu = True
        menu = tb_it.menu
        menu.item_add(None, "Undo", "edit-undo", self.unDoPress)
        menu.item_add(None, "Redo", "edit-redo", self.reDoPress)
        menu.item_separator_add()
        menu.item_add(None, "Copy", "edit-copy", self.copyPress)
        menu.item_add(None, "Paste", "edit-paste", self.pastePress)
        menu.item_add(None, "Cut", "edit-cut", self.cutPress)
        menu.item_separator_add()
        menu.item_add(None, "Select All", "edit-select-all",
                      self.selectAllPress)

        self.item_append("edit-find-replace", "Find",
                         lambda self, obj: self._parent.show_find())
        # -----------------------
        #
        # -- Options Dropdown Menu --
        #
        # self.item_append("settings", "Options", self.optionsPress)
        tb_it = self.item_append("preferences-desktop", "Options")
        tb_it.menu = True
        menu = tb_it.menu
        self._parent.wordwrap = self._parent.config['word_wrap']
        it = menu.item_add(None, "Wordwrap", None, self.optionsToggle)
        chk = Check(canvas)
        it.content = chk
        it.content.state = (self._parent.config['word_wrap'] == ELM_WRAP_MIXED)
        self.menu_item_ww = it

        it = menu.item_add(None, "Line Numbers", None, self.optionsToggle)
        chk = Check(canvas)
        it.content = chk
        it.content.state = self._parent.config['line_numbers']
        self.menu_item_ln = it


        '''it = menu.item_add(None, "New Instance", None, self.optionsNew)
        chk = Check(canvas, disabled=True)
        it.content = chk
        if self._parent.newInstance:
            it.content.state = True
        else:
            it.content.state = False'''

        # ---------------------------

        self.item_append("dialog-information", "About",
                         self.show_about)

    def show_about(self, obj, it):
        try:
            AboutWindow(self, title="ePad", standardicon="accessories-text-editor", \
                        version=__version__, authors=AUTHORS, \
                        licen=LICENSE, webaddress=__github__, \
                        info=INFO)
        except InstanceError:
            pass

    #############################################################
    # Hack to toggle word wrap state with line numbers state   ##
    #############################################################
    def optionsToggle(self, obj, it):
        wordwrap = self._parent.config['word_wrap']
        linenum = self._parent.config['line_numbers']

        if it.text == "Wordwrap":
            if wordwrap == ELM_WRAP_MIXED:
                wordwrap = ELM_WRAP_NONE
                it.content.state = False
                linenum = self.menu_item_ln.content.state = True
            else:
                wordwrap = ELM_WRAP_MIXED
                it.content.state = True
                linenum = self.menu_item_ln.content.state = False
        else:
            if linenum:
                linenum = it.content.state = False
                wordwrap = ELM_WRAP_MIXED
                self.menu_item_ww.content.state = True
            else:
                linenum = it.content.state = True
                wordwrap = ELM_WRAP_NONE
                self.menu_item_ww.content.state = False
        # Change word wrap state of all open tabs
        for tab in self._parent.tabbs.tabs:
            tab.mainEn.line_wrap_set(wordwrap)
            # for some reason have to reset font style
            while tab.mainEn.text_style_user_peek():
                tab.mainEn.text_style_user_pop()
            tab.mainEn.text_style_user_push(self._parent.tabbs.currentTab.font_style)
        # Change line number state of all open tabs
        if linenum:
            for tab in self._parent.tabbs.tabs:
                tab.entry_box.pack_before(tab.sep, tab.mainEn)
                tab.sep.show()
                tab.entry_box.pack_before(tab.line_list, tab.sep)
                tab.checkLineNumbers()
                tab.line_list.show()
        else:
            for tab in self._parent.tabbs.tabs:
                tab.entry_box.unpack(tab.line_list)
                tab.entry_box.unpack(tab.sep)
                tab.line_list.hide()
                tab.sep.hide()
        # Update Config file
        self._parent.config['word_wrap'] = wordwrap
        self._parent.config['line_numbers'] = linenum
        reset_close_menu_count(None)

    def unDoPress(self, obj, it):

        self._parent.tabbs.currentTab.unDo()
        reset_close_menu_count(None)

    def reDoPress(self, obj, it):
        self._parent.tabbs.currentTab.reDo()
        reset_close_menu_count(None)

    def copyPress(self, obj, it):
        self._parent.tabbs.currentTab.mainEn.selection_copy()
        reset_close_menu_count(None)

    def itemClicked(self, obj, item):
        if item.menu_get() is None and item.selected_get():
            item.selected_set(False)
        elif item.menu_get():
            CLOSE_MENU(item, item.text_get())

    def pastePress(self, obj, it):
        self._parent.tabbs.currentTab.mainEn.selection_paste()
        reset_close_menu_count(None)

    def cutPress(self, obj, it):
        self._parent.tabbs.currentTab.mainEn.selection_cut()
        reset_close_menu_count(None)

    def selectAllPress(self, obj, it):
        self._parent.tabbs.currentTab.mainEn.select_all()
        reset_close_menu_count(None)

    def optionsNew(self, obj, it):
        self._parent.newInstance = not self._parent.newInstance
        if self._parent.newInstance:
            it.content.state = True
        else:
            it.content.state = False
        reset_close_menu_count(None)


class ePadConf(object):
    """
    config file object
    """

    # Config version follows major:minor format
    #  an increase in major version number indicates incompatible
    #     config file format change
    #  an increase in minor for compatible config file format change
    __config_version_major = 0
    __config_version_minor = 1
    __config_version = '{0}.{1}'.format(__config_version_major,
                                        __config_version_minor)
    default = {"version": __config_version,
               "word_wrap": ELM_WRAP_NONE,
               "font": "Sans",
               "font_size": EPadEntry.default_font_size,
               "font_style": "Normal",
               "font_weight": "Normal",
               "font_width": "Normal",
               "line_numbers": True,
               "show_hidden": False,
               "show_pos": True,
               "max_undo": 100,
               "case_sensitive": False,
               "notify_root": True,
               "new_instance": False,
               "show_hidden": False,
               "autosave": False}

    def __init__(self):
        # sys.platform returns 'linux2' in py2 and linux in py3
        #   hence hackish way to ensure compatibility
        if sys.platform[:5] != 'linux':
            # only support for linux is implemented
            raise RuntimeError("Unsupported OS: patches accepted.")

        self.__file_name = "{0}.json".format(__appname__)
        # we follow the XDG spec and support $XDG_CONFIG_HOME.
        #   Also, traditionally, Linux apps store their data in
        #    "~/.config/<appname>" instead of "~/.local/share/<appname>".
        self.__dir_path = os.getenv('XDG_CONFIG_HOME',
                                    os.path.expanduser('~/.config'))
        self.__dir_path = os.path.join(self.__dir_path,
                                       '{0}'.format(__appname__))
        # Better way to do the below in py3 but ...
        try:
            os.makedirs(self.__dir_path)
        except OSError:
            if not os.path.isdir(self.__dir_path):
                raise
        self.path = os.path.join(self.__dir_path, self.__file_name)
        # Initialize config data
        self.get_config()

    def get_config(self):
        """
        Initializes the config data
        """
        if os.path.exists(self.path):
            try:
                with open(self.path) as config_file:
                    self.data = json.load(config_file)
            except ValueError:
                print_err('Config file corruption!')
                self.default_config()
        else:
            self.default_config()

        if not self.__validate():
            print_err('Config file corruption!')
            self.default_config()

        version = self.data["version"]
        if version.split('.')[0] != str(self.__config_version_major):
            print_err('Config version mismatch')
            self.default_config()

    def __validate(self):
        """
        Return true on Valid config keys. No checks on config values
        """
        return set(ePadConf.default) == set(self.data)

    def write(self):
        with open(self.path, "w") as config_file:
            json.dump(self.data, config_file, sort_keys=True, indent=4, separators=(',', ': '))

    def default_config(self):
        """
        Create a config file
        """
        self.data = ePadConf.default
        self.write()

    def __getitem__(self, setting):
        """
        Returns a setting.
        """
        try:
            value = self.data[setting]
        except KeyError:
            print_err('Invalid settings: "{0}"'.format(setting))
            value = None
        return value

    def __setitem__(self, setting, value):
        """
        Update a setting. No validation on Value. Save file after update.
        """
        self.__safe_set(setting, value)
        self.write()

    def __safe_set(self, setting, value):
        """
        Update a setting. No validation on Value.
        """
        try:
            if self.data[setting] == value:
                return
        except KeyError:
            print_err('Invalid settings: "{0}"'.format(setting))
            return
        self.data[setting] = value

    def update(self, settings=None, **kwargs):
        """
        Update Multiple settings. No validation on Value.
            Saves file after update.
        Usage:
                config = ePadConf()
                config.update(font='Mono',font_size=24)
                config.update({'font': 'Mono', 'font_size': 24})
        """
        if settings is not None:
            for setting, value in list(settings.items())\
            if isinstance(settings, Mapping) else settings:
                self.__safe_set(setting, value)
        for setting, value in list(kwargs.items()):
            self.__safe_set(setting, value)
        self.write()


if __name__ == "__main__":

    ourFiles = sys.argv

    #Remove ePad.py from the arguments
    del ourFiles[0]

    # Start App
    elementary.init()
    GUI = Interface()
    if ourFiles:
        GUI.launch([ourFiles, None])
    else:
        GUI.launch([None, os.getcwd()])
    elementary.run()
    GUI.file_slctr.shutdown()
    # Shutdown App
    elementary.shutdown()
